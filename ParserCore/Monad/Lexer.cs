using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;

/// <summary>
/// This is a set of static classes to define appropriate extension methods
/// for monadic parsing.
/// </summary>
namespace WaywardGamers.KParser.Monad
{
    /// <summary>
    /// The lexer takes the broken up string and performs an analysis to group
    /// words together (if necessary) and notate what type of token each
    /// word group represents.  This list of tokens will then be passed on
    /// to the next stage of parsing.
    /// </summary>
    public static class Lexer
    {
        #region Core functions that know the underlying parser representation
        /// <summary>
        /// This function always fails (consumes no input), regardless of input.
        /// </summary>
        /// <typeparam name="T">The type of result object generated.</typeparam>
        /// <returns>Returns a new empty Consumed object where none of the input was consumed,
        /// but the input position is marked..</returns>
        public static P<T, string> Fail<T>(string message)
        {
            return input =>
                new Consumed<T, string>(
                    false,
                    new ParseResult<T, string>(
                        new ErrorInfo(input.Position, Enumerable.Empty<string>(), message)));
        }

        /// <summary>
        /// Return(x) is a parser that always succeeds with result x, without consuming any input.
        /// </summary>
        /// <typeparam name="T">The type of result object generated.</typeparam>
        /// <param name="x">The result object generated.</param>
        /// <returns>Always returns a Consumed object containing a ParseResult
        /// built with the provided result object.</returns>
        public static P<T, string> Return<T>(T x)
        {
            return input =>
                new Consumed<T, string>(
                    false,
                    new ParseResult<T, string>(
                        x,
                        input,
                        input,
                        new ErrorInfo(input.Position)));
        }

        /// <summary>
        /// This function runs parser p1 on the input.  If it fails, return
        /// null.  If it succeeds, run the provided function on the result
        /// of the initial function.
        /// </summary>
        /// <typeparam name="T">The type of result object generated by the first function.</typeparam>
        /// <typeparam name="U">The type of result object generated by the second function.</typeparam>
        /// <param name="p1">The initial parser to run.</param>
        /// <param name="f">The function defining the second parser to run.</param>
        /// <returns>Returns the completely constructed parser.</returns>
        public static P<U, string> Then<T, U>(this P<T, string> p1, Func<T, P<U, string>> f)
        {
            return input =>
            {
                Consumed<T, string> consumed1 = p1(input);

                if (consumed1.ParseResult.Succeeded)
                {
                    Consumed<U, string> consumed2 = f(consumed1.ParseResult.Result)(consumed1.ParseResult.RemainingInput);
                    return new Consumed<U, string>(
                           consumed1.HasConsumedInput || consumed2.HasConsumedInput,
                           consumed2.HasConsumedInput
                               ? consumed2.ParseResult
                               : consumed2.ParseResult.MergeError(consumed1.ParseResult.ErrorInfo));
                }
                else
                {
                    return new Consumed<U, string>(
                        consumed1.HasConsumedInput,
                        new ParseResult<U, string>(consumed1.ParseResult.ErrorInfo));
                }
            };
        }

        /// <summary>
        /// Then_ is a variant on Then.  It runs p1 predicate on the input,
        /// discards the results, and runs p2 on the result of the p1 function.
        /// </summary>
        /// <typeparam name="T">The type of result object generated by the first function.</typeparam>
        /// <typeparam name="U">The type of result object generated by the second function.</typeparam>
        /// <param name="p1">The first parser to run.</param>
        /// <param name="p2">The second parser to run.</param>
        /// <returns>Returns the combined parser function.</returns>
        public static P<U, string> Then_<T, U>(this P<T, string> p1, P<U, string> p2)
        {
            return p1.Then<T, U>(dummy => p2);
        }


        /// <summary>
        /// p1.Or(p2) tries p1, but if it fails without consuming input, runs p2 instead.
        /// </summary>
        /// <typeparam name="T">The type of result object generated.</typeparam>
        /// <param name="p1">The first parser to run.</param>
        /// <param name="p2">The second parser to run.</param>
        /// <returns>Returns the combined parser function.</returns>
        public static P<T, string> Or<T>(this P<T, string> p1, P<T, string> p2)
        {
            return input =>
            {
                Consumed<T, string> consumed1 = p1(input);

                if (consumed1.ParseResult.Succeeded || consumed1.HasConsumedInput)
                {
                    return consumed1;
                }
                else
                {
                    Consumed<T, string> consumed2 = p2(input);

                    if (consumed2.HasConsumedInput)
                        return consumed2;

                    return new Consumed<T, string>(
                        consumed2.HasConsumedInput,
                        consumed2.ParseResult.MergeError(consumed1.ParseResult.ErrorInfo));
                }
            };
        }

        /// <summary>
        /// p.Tag(label) makes it so if p fails without consuming input, the error "expected label" occurs
        /// </summary>
        /// <typeparam name="T">The type of the result object.</typeparam>
        /// <param name="p">The predicate this is extending.</param>
        /// <param name="label">A string to use to tag the resulting parse state.</param>
        /// <returns></returns>
        public static P<T, string> Tag<T>(this P<T, string> p, string label)
        {
            return input => p(input).Tag(label);
        }


        /// <summary>
        /// Satisfy(pred) succeeds parsing a string only if the string matches the predicate.
        /// </summary>
        /// <param name="pred">The predicate comparitor.</param>
        /// <returns></returns>
        public static P<string, string> Satisfy(Predicate<string> pred)
        {
            return input =>
            {
                if (input.Position >= input.Input.Count)
                {
                    return new Consumed<string, string>(
                        false,
                        new ParseResult<string, string>(
                            new ErrorInfo(
                                input.Position,
                                Enumerable.Empty<string>(),
                                "unexpected end of input")));
                }
                else if (!pred(input.Input[input.Position]))
                {
                    return new Consumed<string, string>(
                        false,
                        new ParseResult<string, string>(
                            new ErrorInfo(
                                input.Position,
                                Enumerable.Empty<string>(),
                                "unexpected string '" + input.Input[input.Position] + "'")));
                }
                else
                {
                    return new Consumed<string, string>(
                        true,
                        new ParseResult<string, string>(
                            input.Input[input.Position],
                            input,
                            new ParserState<string>(
                                input.Position + 1,
                                input.Input),
                            new ErrorInfo(input.Position + 1)));
                }
            };
        }

        /// <summary>
        /// Item() consumes the first element of the input string list and returns it as a result
        /// </summary>
        /// <returns></returns>
        public static P<string, string> Item()
        {
            return Satisfy(c => true).Tag("any string");
        }


        public static P<TokenType, string> Literal(List<string> toParse, List<string> consumed, TokenType result)
        {
            if (consumed == null)
                consumed = new List<string>();

            if (toParse.Count == 0)
                return Lexer.Return(result);
            else
                return Satisfy(c => c == toParse.First())
                    .Then_(Literal(toParse.Skip(1).ToList(), consumed, result));
        }

        #endregion

        #region Tokenizer


        // The Tokenizer section takes the scanned list of words and groups certain ones together.
        // It returns a list of word 'clusters'.

        static Predicate<string> IsCapitalized = (s => Regex.Match(s, @"^[A-Z]").Success);
        static Predicate<string> IsPosessive = (s => Regex.Match(s, @"'s$").Success);
        static Predicate<string> IsYou = (s => Regex.Match(s, @"You").Success);


        public static P<TokenType, string> Prefixes =
            Literal(new List<string> { "Cover", "!" }, null, TokenType.CoverPrefix).Or(
            Literal(new List<string> { "Resist", "!" }, null, TokenType.ResistPrefix).Or(
            Literal(new List<string> { "Bust", "!" }, null, TokenType.BustPrefix).Or(
            Literal(new List<string> { "Dice", "Roll", "!" }, null, TokenType.DiceRollPrefix).Or(
            Literal(new List<string> { "Magic", "Burst", "!" }, null, TokenType.MagicBurstPrefix).Or(
            Literal(new List<string> { "Additional", "Effect", ":" }, null, TokenType.AdditionalEffectPrefix).Or(
            Literal(new List<string> { "Skillchain", ":" }, null, TokenType.SkillchainPrefix)))))));


        static string Combine(string word1, string word2)
        {
            return word1 + word2;
        }

        static string CombineWords(string word1, string word2)
        {
            return word1 + " " + word2;
        }

        public static List<Token> Tokenize(List<string> wordList)
        {
            List<Token> tokenList = new List<Token>();

            ParserState<string> state = new ParserState<string>(0, wordList);

            var which = Prefixes(state);

            return tokenList;
        }

        #endregion

    }

}
